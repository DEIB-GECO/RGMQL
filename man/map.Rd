% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AllGenerics.R, R/gmql_map.R
\docType{methods}
\name{map}
\alias{map}
\alias{map,GMQLDataset-method}
\alias{map}
\alias{map-method}
\title{Method map}
\usage{
map(x, y, ...)

\S4method{map}{GMQLDataset}(x, y, ..., joinBy = NULL)
}
\arguments{
\item{x}{GMQLDataset class object}

\item{y}{GMQLDataset class object}

\item{...}{a series of expressions separated by comma in the form 
\emph{key} = \emph{aggregate}. The \emph{aggregate} is an object of 
class AGGREGATES. The aggregate functions available are: \code{\link{SUM}}, 
\code{\link{COUNT}}, \code{\link{MIN}}, \code{\link{MAX}}, 
\code{\link{AVG}}, \code{\link{MEDIAN}}, \code{\link{STD}}, 
\code{\link{BAG}}, \code{\link{BAGD}}, \code{\link{Q1}}, 
\code{\link{Q2}}, \code{\link{Q3}}.
Every aggregate accepts a string value, except for COUNT, which does not 
have any value.
Argument of 'aggregate function' must exist in schema, i.e. among region 
attributes. Two styles are allowed:
\itemize{
\item list of key-value pairs: e.g. sum = SUM("pvalue")
\item list of values: e.g. SUM("pvalue")
}
"mixed style" is not allowed}

\item{joinBy}{list of evalation functions to define evaluation on metadata:
\itemize{
\item{ \code{\link{FN}}(value): Fullname evaluation, two attributes match 
if they both end with \emph{value} and, if they have further prefixes,
the two prefix sequence are identical.}
\item{ \code{\link{EX}}(value): Exact evaluation, only attributes exactly 
as \emph{value} match; no further prefixes are allowed.}
\item{ \code{\link{DF}}(value): Default evaluation, the two attributes match 
if both end with \emph{value}.}
}}
}
\value{
GMQLDataset object. It contains the value to use as input 
for the subsequent GMQLDataset method
}
\description{
Wrapper to GMQL MAP operator

It computes, for each sample in the right dataset, aggregates over the 
values of the right dataset regions that intersect with a region in a left 
dataset sample, for each region of each sample in the left dataset;
The number of generated output samples is the Cartesian product 
of the samples in the two input datasets;
each output sample has the same regions as the related input left dataset 
sample, with their attributes and values, plus the attributes computed as 
aggregates over right region values.
Output sample metadata are the union of the related input sample metadata,
whose attribute names are prefixed with "left" or "right" respectively.
}
\details{
When the joinby clause is present, only pairs of samples of left_input_data 
and of right_input_data with metadata M1 and M2 respectively that satisfy 
the joinby condition are considered.

The clause consists of a list of metadata attribute names that must be
present with equal values in both M1 and  M2
}
\examples{

## Thi statement initializes and runs the GMQL server for local execution 
## and creation of results on disk. Then, with system.file() it defines 
## the path to the folders "DATASET" and "DATASET_GDM" in the subdirectory 
## "example" of the package "RGMQL" and opens such folder as a GMQL 
## dataset named "exp" and "ref" respectively using customParser

init_gmql()
test_path <- system.file("example", "DATASET", package = "RGMQL")
test_path2 <- system.file("example", "DATASET_GDM", package = "RGMQL")
exp = read_dataset(test_path)
ref = read_dataset(test_path2)

# It counts the number of regions in each sample from exp that overlap with 
# a ref region, and for each ref region it computes the minimum score 
# of all the regions in each exp sample that overlap with it. 
# The MAP joinby option ensures that only the exp samples referring to 
# the same 'cell_tissue' of a ref sample are mapped on such ref sample; 
# exp samples with no cell_tissue metadata attribute, or with such metadata 
# but with a different value from the one(s) of ref sample(s), 
# are disregarded.

out = map(ref, exp, minScore = MIN("score"), 
joinBy = list(DF("cell_tissue")))

}
