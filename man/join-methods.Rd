% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Join.R
\docType{methods}
\name{join}
\alias{join}
\alias{join}
\alias{join,}
\alias{GMQLDataset-methods}
\title{GMQL Operation: JOIN}
\usage{
join(x, y, by = NULL, ...)

\S4method{join}{GMQLDataset}(x, y, by = NULL, genometric_predicate = NULL,
  region_output = "contig")
}
\arguments{
\item{x}{GMQLDataset class object}

\item{y}{GMQLDataset class object}

\item{by}{list of CONDITION objects where every object contains 
the name of metadata to be used in semijoin, or simple string concatenation 
of name of metadata, e.g. c("cell_type", "attribute_tag", "size") 
without declaring condition.
The CONDITION's available are:
\itemize{
\item{\code{\link{FULL}}: Fullname evaluation, two attributes match 
if they both end with value and, if they have a further prefixes,
the two prefix sequence are identical}
\item{\code{\link{EXACT}}: Exact evaluation, only attributes exactly 
as value will match; no further prefixes are allowed. }
}
Every condition accepts only one string value. (e.g. FULL("cell_type") )
In case of single concatenation with no CONDITION, or list with some value 
without conditon, the metadata are considered having default 
evaluation: the two attributes match if both end with value.}

\item{genometric_predicate}{is a list of lists of DISTAL object
For details of DISTAL objects see:
\code{\link{DLE}}, \code{\link{DGE}}, \code{\link{DL}}, \code{\link{DG}},
\code{\link{MD}}, \code{\link{UP}}, \code{\link{DOWN}}}

\item{region_output}{single string that declare which region is given in 
output for each input pair of left dataset right dataset regions 
satisfying the genometric predicate:
\itemize{
\item{left: outputs the anchor regions from left_input_data that satisfy 
the genometric predicate}
\item{right: outputs the experiment regions from right_input_data that 
satisfy the genometric predicate}
\item{int (intersection): outputs the overlapping part (intersection) 
of the left_input_data and right_input_data regions that satisfy 
the genometric predicate; if the intersection is empty, 
no output is produced}
\item{contig: outputs the concatenation between the left_input_data and 
right_input_data regions that satisfy the genometric predicate, 
(i.e. the output regionis defined as having left (right) coordinates
equal to the minimum (maximum) of the corresponding coordinate values 
in the left_input_data and right_input_data regions satisfying 
the genometric predicate)}
}}
}
\value{
GMQLDataset class object. It contains the value to use as input 
for the subsequent GMQL function
}
\description{
It takes in input two datasets, respectively known as nchor (left) 
and experiment (right) and returns a dataset of samples consisting of 
regions extracted from the operands according to the specified condition
(a.k.a \emph{genometric_predicate}).
The number of generated output samples is the Cartesian product 
of the number of samples in the anchor and in the experiment dataset 
(if \emph{by} is not specified).
The output metadata are the union of the input metadata, 
with their attribute names prefixed with left or right respectively.
}
\examples{

# Given a dataset 'hm' and one called 'tss' with a sample including 
# Transcription Start Site annotations, it searches for those regions of hm 
# that are at a minimal distance from a transcription start site (TSS) 
# and takes the first/closest one for each TSS, provided that such distance 
# is lesser than 120K bases and joined 'tss' and 'hm' samples are obtained 
# from the same provider (joinby clause).

init_gmql()
test_path <- system.file("example", "DATASET", package = "RGMQL")
test_path2 <- system.file("example", "DATASET_GDM", package = "RGMQL")
TSS = read_dataset(test_path)
HM = read_dataset(test_path2)
join_data = join(TSS, HM, 
genometric_predicate = list(list(MD(1), DLE(120000))), by = c("provider"), 
region_output="RIGHT")

}
