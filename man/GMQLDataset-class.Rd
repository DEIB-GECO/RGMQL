% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Dataset-class.R, R/Select.R, R/Union.R
\docType{class}
\name{GMQLDataset-class}
\alias{GMQLDataset-class}
\alias{GMQLDataset}
\alias{filter}
\alias{filter,}
\alias{filter-methods}
\alias{union}
\alias{union,}
\alias{GMQLDataset-method}
\title{Class GMQLDataset}
\usage{
GMQLDataset(value)

filter(data, m_predicate = NULL, r_predicate = NULL, semi_join = NULL,
  semi_join_negation = FALSE, semi_join_dataset = NULL)

\S4method{union}{GMQLDataset,GMQLDataset}(x, y)
}
\arguments{
\item{value}{value associated to GMQL dataset}

\item{m_predicate}{logical predicate made up by R logical operation 
on metadata attribute. 
Only !, |, ||, &, && are admitted.}

\item{r_predicate}{logical predicate made up by R logical operation 
on chema region values. 
Only !, |, ||, &, && are admitted.}

\item{semi_join}{list of CONDITION objects where every object contains 
the name of metadata to be used in semijoin, or simple string concatenation 
of name of metadata, e.g. c("cell_type", "attribute_tag", "size") 
without declaring condition.
The CONDITION's available are:
\itemize{
\item{\code{\link{FULL}}: Fullname evaluation, two attributes match 
if they both end with value and, if they have a further prefixes,
the two prefix sequence are identical}
\item{\code{\link{EXACT}}: Exact evaluation, only attributes exactly 
as value will match; no further prefixes are allowed. }
}
Every condition accepts only one string value. (e.g. FULL("cell_type") )
In case of single concatenation with no CONDITION or list with some value 
without conditon, the metadata are considered having default 
evaluation: the two attributes match if both end with value.}

\item{semi_join_negation}{logical value: T => semijoin is perfomed 
considering semi_join NOT IN semi_join_dataset, F => semijoin is performed 
considering semi_join IN semi_join_dataset}

\item{semi_join_dataset}{GMQLDataset class object}

\item{x}{GMQLDataset class object}

\item{y}{GMQLDataset class object}

\item{x}{GMQLDataset class object}
}
\value{
GMQLDataset class object. It contains the value to use as input 
for the subsequent GMQL function

GMQLDataset class object. It contains the value to use as input 
for the subsequent GMQL function
}
\description{
Abstract class representing GMQL dataset

It returns all the samples satisfying the predicate on metadata.
If regions are specified, returns regions satisfying the predicate 
on regions.
If semijoin clauses are specified they are applied, too.
When semijoin is defined, it extracts those samples containing all metadata 
attribute defined in semijoin clause with at least one metadata value 
in common with semi join dataset.
If no metadata in common between input dataset and semi join dataset, 
no sample is extracted.

It is used to integrate homogeneous or heterogeneous samples of two datasets 
within a single dataset; for each sample of either input dataset, 
a result sample is created as follows:
\itemize{
\item {Metadata are the same as in the original sample.}
\item {Resulting schema is obtained by projecting the schema 
of the right dataset over the schema of the left one
(more properly, it will be performed by adding to the schema of the 
left dataset the region attributes of the right dataset which are not 
identical to those of the left dataset)}
\item {Regions are the same (in coordinates and attribute values) 
as in the original sample.
Region attributes which are missing in an input dataset sample 
w.r.t. the merged schema are set to null.}
}
For what concerns metadata, attributes of samples from the left (right) 
input dataset are prefixed with the strings LEFT (RIGHT), so as to trace 
the dataset to which they originally belonged.
}
\section{Slots}{

\describe{
\item{\code{value}}{value associated to GMQL dataset}
}}

\examples{

## It selects from input data samples of patients younger than 70 years old, 
## based on filtering on sample metadata attribute Patient_age

init_gmql()
test_path <- system.file("example", "DATASET", package = "RGMQL")
input <- read_dataset(test_path)
s <- subset(input, Patient_age < 70)


\dontrun{

It creates a new dataset called 'jun_tf' by selecting those samples and 
their regions from the existing 'data' dataset such that:
Each output sample has a metadata attribute called antibody_target 
with value JUN.
Each output sample also has not a metadata attribute called cell 
that has the same value of at least one of the values that a metadata 
attribute equally called cell has in at least one sample 
of the 'join_data' dataset.
For each sample satisfying previous condition,only its regions that 
have a region attribute called pValue with the associated value 
less than 0.01 are conserved in output


init_gmql()
test_path <- system.file("example", "DATASET", package = "RGMQL")
test_path2 <- system.file("example", "DATASET_GDM", package = "RGMQL")
data <- read_dataset(test_path)
join_data <-  read_dataset(test_path2)
jun_tf <- filter(data, antibody_target == 'JUN', pValue < 0.01, c("cell"), 
TRUE, semi_join_dataset = join_data )

}


## It creates a dataset called full which contains all samples from the 
## datasets data1 and data2 whose schema is defined by merging the two 
## dataset schemas.
## (union of all the attributes present in the two input datasets).

init_gmql()
test_path <- system.file("example", "DATASET", package = "RGMQL")
test_path2 <- system.file("example", "DATASET_GDM", package = "RGMQL")
data1 <- read_dataset(test_path)
data2 <- read_dataset(test_path2)

res <- union(data1, data2)

}
