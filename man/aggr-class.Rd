% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aggregate-class.R
\name{AGGREGATES}
\alias{AGGREGATES}
\alias{SUM}
\alias{AGGREGATES}
\alias{MIN}
\alias{AGGREGATES}
\alias{MAX}
\alias{AGGREGATES}
\alias{AVG}
\alias{AGGREGATES}
\alias{BAG}
\alias{AGGREGATES}
\alias{COUNT}
\alias{AGGREGATES}
\alias{STD}
\alias{AGGREGATES}
\alias{MEDIAN}
\alias{AGGREGATES}
\alias{Q1}
\alias{AGGREGATES}
\alias{Q2}
\alias{AGGREGATES}
\alias{Q3}
\alias{AGGREGATES}
\alias{BAGD}
\title{AGGREGATES object class constructor}
\usage{
SUM(value)

MIN(value)

MAX(value)

AVG(value)

BAG(value)

COUNT()

STD(value)

MEDIAN(value)

Q1(value)

Q2(value)

Q3(value)

BAGD(value)
}
\arguments{
\item{value}{string identifying name of metadata or region attribute}
}
\value{
aggregate object
}
\description{
This class constructor is used to create instances of AGGREGATES object,
to be used in GMQL functions that require aggregate on value.
}
\details{
\itemize{
\item{SUM: It prepares input parameter to be passed to the library 
function sum, performing all the type conversions needed  }
\item{COUNT: It prepares input parameter to be passed to the library 
function count, performing all the type conversions needed }
\item{MIN:It prepares input parameter to be passed to the library 
function minimum, performing all the type conversions needed  }
\item{MAX: It prepares input parameter to be passed to the library 
function maximum, performing all the type conversions needed }
\item{BAG: It prepares input parameter to be passed to the library 
function bag, this function creates comma-separated strings of 
attribute values, performing all the types conversions needed}
\item{BAGD: It prepares input parameter to be passed to the library 
function bag, this function creates comma-separated strings of distinct 
attribute values, performing all the types conversions needed}
\item{AVG: It prepares input parameter to be passed to the library 
function mean, performing all the type conversions needed }
\item{MEDIAN: It prepares input parameter to be passed to the library 
function median, performing all the type conversions needed }
\item{STD: It prepares input parameter to be passed to the library 
function standard deviation, performing all the type conversions needed}
\item{Q1: It prepares input parameter to be passed to the library 
function fist quartile, performing all the type conversions needed}
\item{Q2: It prepares input parameter to be passed to the library 
function second quartile, performing all the type conversions needed }
\item{Q3: It prepares input parameter to be passed to the library 
function third quartile, performing all the type conversions needed }
}
}
\examples{

## local with CustomParser
init_gmql()
test_path <- system.file("example", "DATASET", package = "RGMQL")
exp = read_dataset(test_path)

## This statement copies all samples of exp into res dataset, and 
## then calculates new metadata attributes for each of them: 
## sum_score is the sum of score of the sample regions.

res = extend(exp, sum_score = SUM("score"))

## This statement copies all samples of exp into res dataset, 
## and then calculates new metadata attributes for each of them: 
## MinP is the minimum pvalue of the sample regions.

res = extend(exp, minP = MIN("pvalue"))

## This statement copies all samples of exp into res dataset, 
## and then calculates new metadata attributes for each of them: 
## max_score is the maximum score of the sample regions.

res = extend(exp, max_score = MAX("score"))

## The following cover operation produces output regions where at least 2 
## and at most 3 regions ofexp overlap, having as resulting region 
## attributes the average signal of the overlapping regions; 
## the result has one sample for each input cell.

res = cover(exp, 2, 3, groupBy = list(DF("cell")), 
avg_signal = AVG("signal") )

## It copies all samples of DATA into OUT dataset, and then for each of 
## them it adds another metadata attribute, allScores, 
## which is the aggregation comma-separated list of all the values 
## that the region attribute score takes in the sample.

out = extend(exp, allScore = BAG("score"))

## counts the regions in each sample and stores their number as value 
## of the new metadata RegionCount attribute of the sample.

out = extend(exp, RegionCount = COUNT())

## This statement copies all samples of exp into res dataset, 
## and then calculates new metadata attributes for each of them: 
## std_score is the standard deviation score of the sample regions.

res = extend(exp, std_score = STD("score"))

## This statement copies all samples of exp into res dataset, 
## and then calculates new metadata attributes for each of them: 
## m_score is the median score of the sample regions.

res = extend(exp, m_score = MEDIAN("score"))


}
